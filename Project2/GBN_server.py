# -*- coding: utf-8 -*-
"""GBNserver.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V7iish5DimOlIibIhvXtlmvYO50dlp9M
"""

import socket
import struct
from collections import OrderedDict
from threading import Thread, Lock
import math
import os
import numpy as np
import select

def computeChecksum(data):
		sum = 0
		for i in range(0, len(data), 2):
			if i+1 < len(data):
				data16 = ord(data[i]) + (ord(data[i+1]) << 8)
				interSum = sum + data16
				sum = (interSum & 0xffff) + (interSum >> 16)
		return ~sum & 0xffff



class PackageReciever(Thread):
  
  def __init__(self, recievesock, buffersize, maxseqnum, maxwdsize,timeout, dropACKprobs=0.05, lostPacketProb=0.1):
    Thread.__init__(self)
    self.rcvsock=recievesock
    self.window=OrderedDict()
    self.buffersize=buffersize
    self.windowsize=int(maxwdsize)
    self.rcvbase=0
    self.maxseqnum=maxseqnum #maxseqnum is the total number of sequence numbers (i.e. 16) NOT THE LARGEST SEQUENCE NUMBER (i.e. 15)
    self.timeout=float(timeout)
    self.Recieving=False
    self.dropACKprobs=dropACKprobs
    self.lostPacketProb=lostPacketProb
    

  def checkpacket(self, data, checksum):
    check= computeChecksum(data) == checksum
    if not check:
      print('Error was found with Packet.......')
    return 1 if check  else 0
 
  def openPacket(self, packet):
    sequencenum=struct.unpack('I',packet[:4])[0]
    checksum=struct.unpack('H',packet[4:6])[0]
    data=packet[6:].decode('UTF-8','replace')
    return sequencenum, checksum, data
   
  def push2AppLayer(self, data):
    out=open('dataGBN.txt','a')
    out.write(data)
  
  def sendACK(self, ACKnum):
    packet=self.packpacket(ACKnum)
    if ACKnum == self.maxseqnum+1:
      self.rcvsock.sendto(packet, self.sendaddr)
    
    if np.random.rand() <= self.dropACKprobs:
      print('\nACK '+str(ACKnum)+' was dropped, Oops......')
      return None
    self.rcvsock.sendto(packet, self.sendaddr)
    print("\nACK sent: "+str(ACKnum))
  def packpacket(self, ACKnum):
    sequenceNumber = struct.pack('=I', ACKnum)
    checksum = struct.pack('=H', computeChecksum(str(ACKnum)))
    return sequenceNumber + checksum
  
  def run(self):
    timeoutnum=0
    print('\nSTARTING SERVER......')
    while True:
      ready = select.select([self.rcvsock], [], [], self.timeout)
      print('\nSocket is waiting....')
      if not ready[0]:
        if not self.Recieving:
          continue
        else:
          timeoutnum += 1
          if timeoutnum > 5:
            self.sendACK(self.maxseqnum+1)
            print('\nTimeout has occured because client is no longer sending anything......')
            break
      else: 
        #print('\nServer is trying to recieve......')
        packet, self.sendaddr =self.rcvsock.recvfrom(self.buffersize)
        self.Recieving=True
        seqnum, checksum, data= self.openPacket(packet)
        if seqnum +1 >= self.maxseqnum:
          ACKnum = 0
        else:
          ACKnum=seqnum+1
        if self.checkpacket(data+str(seqnum), checksum):  
          #print("\nPacket possibly contains no error......")
          if np.random.rand() < self.lostPacketProb:
            print('\nOops, lost Packet with sequence number '+str(seqnum))
            continue
          if seqnum == self.rcvbase:
            print('\nRecieved Packet with sequence number: '+str(seqnum))
            self.sendACK(ACKnum)
            #self.sendACK(seqnum)
            self.push2AppLayer(data)
            self.rcvbase =ACKnum
          elif seqnum != self.rcvbase:
            print('\nWrong Packet recieved: '+str(seqnum))
            self.sendACK(self.rcvbase)
          else:
            continue
