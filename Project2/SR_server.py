# -*- coding: utf-8 -*-
"""SRserver.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16n8ZWy_qIl-dPebkscBXsOcskencXD0S
"""

import socket
import struct
from collections import OrderedDict
from threading import Thread, Lock
import math
import os
import numpy as np
import select

def computeChecksum(data):
		sum = 0
		for i in range(0, len(data), 2):
			if i+1 < len(data):
				data16 = ord(data[i]) + (ord(data[i+1]) << 8)
				interSum = sum + data16
				sum = (interSum & 0xffff) + (interSum >> 16)
		return ~sum & 0xffff



class PackageReciever(Thread):
  
  def __init__(self, recievesock, buffersize, maxseqnum, maxwdsize,timeout, dropACKprobs=0.05, lostPacketProb=0.1):
    Thread.__init__(self)
    self.rcvsock=recievesock
    self.window=OrderedDict()
    self.buffersize=buffersize
    self.windowsize=int(maxwdsize)
    self.rcvbase=0
    self.maxseqnum=maxseqnum #maxseqnum is the total number of sequence numbers (i.e. 16) NOT THE LARGEST SEQUENCE NUMBER (i.e. 15)
    self.timeout=float(timeout)
    self.Recieving=False
    self.dropACKprobs=dropACKprobs
    self.lostPacketProb=lostPacketProb
    
  def insideWindow(self, num, a, b):
    if a > self.maxseqnum:
      return 1 if num >= b or num <= a - self.maxseqnum else 0
    elif b < 0:
      return 1 if num >= self.maxseqnum + b or num <= a else 0
    else:
      return 1 if num <= a and num >= b else 0

  def checkpacket(self, data, checksum):
    check= computeChecksum(data) == checksum
    if not check:
      print('Error was found with Packet.......')
    return 1 if check  else 0
 
  def openPacket(self, packet):
    sequencenum=struct.unpack('I',packet[:4])[0]
    checksum=struct.unpack('H',packet[4:6])[0]
    data=packet[6:].decode('UTF-8','replace')
    return sequencenum, checksum, data
   
  def push2AppLayer(self, data):
    out=open('dataSR.txt','a')
    out.write(data)
  
  def sendACK(self, ACKnum):
    packet=self.packpacket(ACKnum)
    if np.random.rand() <= self.dropACKprobs:
      print('\nACK '+str(ACKnum)+' was dropped, Oops......')
      return None
    self.rcvsock.sendto(packet, self.sendaddr)
    print("\nACK sent: "+str(ACKnum))
  def packpacket(self, ACKnum):
    sequenceNumber = struct.pack('=I', ACKnum)
    checksum = struct.pack('=H', computeChecksum(str(ACKnum)))
    return sequenceNumber + checksum
  
  def run(self):
    timeoutnum=0
    print('\nSTARTING SERVER......')
    while True:
      ready = select.select([self.rcvsock], [], [], self.timeout)
      print('\nSocket is waiting....')
      if not ready[0]:
        if not self.Recieving:
          continue
        else:
          timeoutnum += 1
          if timeoutnum > 5:
            self.sendACK(self.maxseqnum+1)
            print('\nTimeout has occured because client is no longer sending anything......')
            break
            
      elif len(self.window) < self.windowsize:
        print('\nServer is trying to recieve......')
        packet, self.sendaddr =self.rcvsock.recvfrom(self.buffersize)
        self.Recieving=True
        seqnum, checksum, data= self.openPacket(packet)
        if self.checkpacket(data+str(seqnum), checksum):  
          #print("\nPacket possibly contains no error......")
          if np.random.rand() < self.lostPacketProb:
            print('\nOops, lost Packet with sequence number '+str(seqnum))
            continue
          if self.insideWindow(seqnum, self.rcvbase + self.windowsize - 1, self.rcvbase):
            print('\nRecieved Packet with sequence number: '+str(seqnum))
            self.window[seqnum]= 1
            self.sendACK(seqnum)
            start=self.rcvbase
            while True:
              try:
                if self.window[start] == 1:
                  del self.window[start] 
                self.push2AppLayer(data)
                start +=1
                if start >= self.maxseqnum:
                  start %= self.maxseqnum
              except:
                self.rcvbase=start
                break
                
          elif self.insideWindow(seqnum, self.rcvbase -1, self.rcvbase - self.windowsize):
            print('\nDuplicate packet was recieved and discarded, Resending ACK for duplicate Packet: ' + str(seqnum))
            self.sendACK(seqnum)
            
          else:
            print('\nWrong Packet recieved')
            continue







