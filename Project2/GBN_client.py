# -*- coding: utf-8 -*-
"""GBNclient.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rd03gXbtniitJF9-Nwt-5qMFSDEtb8BL
"""

import socket
import struct
from collections import OrderedDict
from threading import Thread, Lock
import math
import os
import time
import sys
import numpy as np 
import codecs
def computeChecksum(data):
		sum = 0
		for i in range(0, len(data), 2):
			if i+1 < len(data):
				data16 = ord(data[i]) + (ord(data[i+1]) << 8)
				interSum = sum + data16
				sum = (interSum & 0xffff) + (interSum >> 16)
		return ~sum & 0xffff



global window 
global windowLock
global SendComplete
window=OrderedDict()
windowLock=Lock()
SendComplete=False
class AckReciever(Thread):
  
  def __init__(self, sendsock, buffersize, maxseqnum):
    Thread.__init__(self)
    self.sock=sendsock
    self.buffersize=buffersize
    self.maxseqnum=maxseqnum
  def checkACK(self, ACK, checksum):
    return 1 if computeChecksum(str(ACK)) == checksum else 0
  
  def openPacket(self, packet):
    ACKnum=struct.unpack('I',packet[:4])[0]
    checksum=struct.unpack('H',packet[4:6])[0]
    return ACKnum, checksum
   
  def run(self):
    global window
    global windowLock
    global SendComplete
    cfm=1
    while len(window) > 0 or not SendComplete:
   
      ACKpacket, _ = self.sock.recvfrom(self.buffersize)
      ACK, checksum = self.openPacket(ACKpacket)
      if ACK == self.maxseqnum+1:
        SendComplete=1
        break
      elif self.checkACK(ACK, checksum):
        if ACK == 0:
          cfm=self.maxseqnum-1
        else:
          cfm=ACK-1
        if cfm not in window.keys():
          continue
        with windowLock:
          print ("\nACK recieved with sequence number: " + str(ACK))
          for i in window:
            if i == cfm: 
              del window[i]
              break
            else:
              del window[i]

class ProcessFile(object):
  def __init__(self, filename, segmentSize, maxseqnum, Package_No):
    self.filename = filename
    self.segmentSize = segmentSize
    self.maxseqnum = maxseqnum
    self.Package_No = int(Package_No)
    SendComplete=False
  def fragmentation(self):
    data_list = []
    data_pre_list = []
    with open(self.filename, "rb") as f:
#      i = 0
      while True:
        data = f.read(self.segmentSize - 6)        
        if not data:
          break
        data_pre_list.append(data)
#        sequenceNumber = i % self.maxseqnum
 #       checksum = computeChecksum(data+str(sequenceNumber))
 #       data_list.append((sequenceNumber, checksum, data))
#        i += 1
    if len(data_pre_list) < self.Package_No:
      data_pre_list = data_pre_list * ((self.Package_No -len(data_pre_list))/len(data_pre_list)+1)
      data_pre_list = data_pre_list[0:self.Package_No] 
    else:
      data_pre_list=data_pre_list[0:self.Package_No]
    i = 0
    for x in data_pre_list:
      sequenceNumber = i % self.maxseqnum
      checksum = computeChecksum(x+str(sequenceNumber))
      data_list.append((sequenceNumber, checksum, x))
      i += 1
    return data_list
  def fragmentList(self):
    return self.fragmentation()

class SendSegments(Thread):
  def __init__(self, sock, segments, timeout, maxwindowsize, bit_error_probability=0.1):
    Thread.__init__(self)
    self.socket=sock
    self.timeout=timeout
    self.segments = segments
    self.maxwindowsize = maxwindowsize
    self.bit_error_probability = bit_error_probability
    self.sndbase=0

    
  def send(self,packet): 
    self.socket.sendto(packet,(socket.gethostbyname("localhost"),55555))
    
  def packpacket(self, segment):
    
    sequenceNumber = struct.pack('=I', segment[0])
    checksum = struct.pack('=H', segment[1])
    data=segment[2].encode('UTF-8')
    return sequenceNumber, checksum, data
    
  def modifyPacket(self, packet):
    sequenceNumber=packet[0]
    checksum=packet[1]
    data=packet[2]
    
    if np.random.rand() < self.bit_error_probability:
      print('\nOops, bit error accidentally generated.......')
      if np.random.rand() < 0.5:
        d=bytearray(data)
        d[np.random.randint(len(d))]=np.random.randint(256)
        data=bytes(d)

      else:
        s=bytearray(sequenceNumber)
        s[np.random.randint(4)]=np.random.randint(256)
        sequenceNumber=bytes(s)
    print('Sending packet number: '+ str(struct.unpack('I',sequenceNumber)).replace(",","").replace(")","").replace("(",""))
    return sequenceNumber+checksum+data
  
  def run(self):
    list = []
    global window
    global windowLock
    global SendComplete


    while self.segments or not SendComplete:
      
      try:
        if len(window) == 0:
          self.timer=[-1, None]
        
        if len(window) < self.maxwindowsize and self.segments:
          
            # Base < nextsequencenumber
          segment=self.segments.pop(0)
          packetTuple=self.packpacket(segment)
          with windowLock:
            window[segment[0]] = packetTuple # 0 means is about to be sent
            self.send(self.modifyPacket(packetTuple))
        if self.timer[0] == -1 and self.segments: # if 
          self.timer[0]=self.sndbase
          print('timer started')
          self.timer[1]=time.time()

        with windowLock:
          if len(window) == 0 and self.segments:
            continue
          if self.timer[0] != window.keys()[0]:
            self.sndbase=window.keys()[0]
            self.timer[0]=self.sndbase
            print('restarted timer')

            self.timer[1]=time.time()
          elif time.time() - self.timer[1] > self.timeout:
            print('Time out happended for packet: '+str(self.timer[0]))
            self.timer[0]=window.keys()[0]
            self.timer[1]=time.time()
            print('restarted timer because of timeout')

           # if timeout, lock the window and send everything that is still inside
            print("Resending all outstanding packets")
            for pkt in window:
              self.send(self.modifyPacket(window[pkt]))
      except:
        continue